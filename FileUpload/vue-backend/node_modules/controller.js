const path=require('path');
const fse=require('fs-extra');

const multiparty=require("multiparty");
const UPLOAD_DIR=path.resolve(__dirname,"..","target");

const extractExt=filename => filename.slice(filename.lastIndexOf("."),filename.length);//取文件的后缀名

const pipeStream=(path, writeStream)=>{
    new Promise(resolve=>{
        const readStream=fse.createReadStream(path);
        readStream.on('end', ()=>{
            resolve();
        });
        readStream.pipe(writeStream);

    })
}

const mergeFileChunk =async (fileHash, filePath, size)=>{
    const chunkDir =path.resolve(UPLOAD_DIR, fileHash);
    console.log("chunkDir",chunkDir);//E:\lesson\FileUpload\vue-backend\target\8e8007b1f9dc007758ee93b4aee6874f
    const chunkPaths = await fse.readdir(chunkDir);
    console.log("chunkPaths",chunkPaths); //读取目录下的文件
    chunkPaths.sort((a,b)=>a.split("-")[1]-b.split("-")[1]);//将目录下的文件进行排序
    await Promise.all(//将一块一块的二进制文件合并
        chunkPaths.map((chunkPath, index)=>
        pipeStream(
            path.resolve(chunkDir, chunkPath),
            fse.createWriteStream(filePath,{//使用流写入指定位置  （出现写入遗漏问题  未解决）
                start: index * size,
                end :(index+1)*size
            })
            
        ))
    )
}

const resolvePost=req=>
    new Promise(resolve=>{
        //post数据慢慢来
        let chunk="";
        req.on("data",data=>{
            chunk+=data;
        });
        req.on("end",()=>{
            //数据全部到了触发这个函数
            console.log('end',chunk);
            resolve(JSON.parse(chunk));
        });

    });


module.exports=class{//匿名函数   和匿名类
async handleVerifyUpload(req,res){
   // res.end('versadfg')
   //服务器有没有这个文件
   //首先拿到post的data，
   const data=await resolvePost(req);//用函数取得req中的数据
   const {fileHash,filename}=data;//将数据取出（JSON）   并且模块化
   console.log("filename",filename);
   const ext=extractExt(filename);//将后缀名取出来
   console.log("ext",ext);
   console.log("UPLOAD_DIR",UPLOAD_DIR);
   const filePath=path.resolve(UPLOAD_DIR,`${fileHash}${ext}`); //创建一个放文件二进制的文件（tp.jpg）
   console.log("filePath",filePath);

   if(fse.existsSync(filePath)){//检测在这个文件夹下是否存在  若存在检测存在哪些
    console.log("存在");
    res.end(
        JSON.stringify({
            shouldUpload:true,
            uploadedList:[]//存放数据  将检测所存在的文件 告诉客户端 （未实现）
        })
    )
   }else{
    console.log("不存");
       res.end(
           JSON.stringify({
               shouldUpload:false,
               uploadedList:[] //不存在就返回空值
           })
       )}
    }
async handleFormData(req,res){
    const multipart=new multiparty.Form();//取出客户端传过来的From数据表单中的数据
    multipart.parse(req, async (err , fields, files)=>{
        if(err){
            console.log(err);
            res.status=500;
            res.end("服务出错了");
            return;
        }
        const [ chunk ] =files.chunk;
        const [ hash ]=fields.hash;
        const [ fileHash ]=fields.fileHash;
        const [ filename ]= fields.filename;
        console.log( hash, filename,fileHash);
       

        const filePath =path.resolve(UPLOAD_DIR,`${fileHash}`);
        const chunkDir= path.resolve(UPLOAD_DIR,fileHash);
        console.log("移动",path.resolve(chunkDir,hash));
        if(fse.existsSync(filePath)){//检测文件夹下是否存在这个二进制文件
            await fse.move(chunk.path,path.resolve(chunkDir,hash));//将缓存中的二进制文件移到指定目录下
            res.end(" file exist");  //向客户端返回信息
            return;
        }
        if(!fse.existsSync(filePath)){
            await fse.mkdirs(filePath);
            await fse.move(chunk.path,path.resolve(chunkDir,hash));        
        }
        console.log("移动",path.resolve(chunkDir,hash)); 
        console.log("运行移动");
        res.end("接收到了文件");

    })

}
async handleMerge(req ,res){
    console.log("在这个为");
    const data =await resolvePost(req);
    const { filehash , filename , size}=data;
    console.log("filehash",filehash);
    console.log("filename",filename);
    console.log("size",size);
    const ext = extractExt (filename);
    const filePath =path.resolve(UPLOAD_DIR,`${filehash}${ext}`);
    console.log(filePath);
    console.log("运行合并");
    await mergeFileChunk(filehash,filePath,size); //将数据合并  在mergeFileChunk函数中合并
    res.end(
        JSON.stringify({
            code:0, 
            message: "file merged success" 
        })
    )

}
}